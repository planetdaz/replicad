<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual Pixel Matrix – Scale Layout</title>
  <style>
    body {
      background: #f5f5f5;
      font-family: sans-serif;
    }
    svg {
      background: white;
      border: 1px solid #ccc;
      width: 100vw;
      height: auto;
      display: block;
      max-width: 100%;
    }
    .pixel {
      stroke: #4da3ff;
      stroke-width: 1.5;
      fill: none;
    }
    .safe {
      stroke: #cce6ff;
      stroke-width: 1;
      stroke-dasharray: 4 4;
      fill: none;
    }
    .hand {
      stroke: #111;
      stroke-width: 3;
      stroke-linecap: round;
    }
    .hand-thin {
      stroke-width: 2.4; /* 80% of 3 */
      stroke: #111;
    }
    .hand-placeholder {
      stroke: #ccc;
      stroke-width: 2;
    }
    .outline {
      stroke: #000;
      stroke-width: 2;
      fill: none;
    }
  </style>
</head>
<body>

<svg id="svg"></svg>

<script>
/* ---- Physical parameters (mm) ---- */
const cols = 8;
const rows = 3;
const cylinderOD = 44.0; // outer diameter
const visibleDiameter = 34.6; // inner visible diameter
const cylinderGap = 2.75; // gap between outside circles

/* ---- Derived geometry ---- */
const outerRadius = cylinderOD / 2;
const innerRadius = visibleDiameter / 2;
const spacing = 46.75; // center-to-center distance in mm

/* ---- SVG sizing ---- */

const outlineGap = cylinderGap * 3; // triple gap for outline
const margin = cylinderGap; // gap between outline and edge circles
const width = spacing * (cols - 1) + cylinderOD + margin * 2 + outlineGap * 2;
const height = spacing * (rows - 1) + cylinderOD + margin * 2 + outlineGap * 2;

const svg = document.getElementById("svg");
svg.style.width = "100vw";
svg.style.height = "auto";
svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

/* ---- Helpers ---- */
function circle(cx, cy, r, cls) {
  return `<circle cx="${cx}" cy="${cy}" r="${r}" class="${cls}" />`;
}

function hand(cx, cy, angleDeg, length, cls="hand") {
  const rad = (angleDeg - 90) * Math.PI / 180;
  const x2 = cx + Math.cos(rad) * length;
  const y2 = cy + Math.sin(rad) * length;
  return `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" class="${cls}" />`;
}


// ---- Digit hand definitions ----
// Most digits use a 3x2 grid: [ [row0col0, row0col1], [row1col0, row1col1], [row2col0, row2col1] ]
// ':' and '1' use a 3x1 grid: [row0, row1, row2]
// Angles: 0=up, 90=right, 180=down, 270=left
const DIGITS = {
  // ':' is a single column, dots in top and bottom row
  ":": [
    [[180, 180, 180]],
    [[225, 225, 225]],
    [[0, 0, 0]]
  ],
  // ' ' (space) is a single column, all 225° hands
  " ": [
    [[225, 225, 225]],
    [[225, 225, 225]],
    [[225, 225, 225]]
  ],
  "0": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 180, 180], [0, 180, 180]],
    [[0, 90, 90], [0, 270, 270]]
  ],
  "1": [
    [[180, 180, 180]],
    [[0, 180, 180]],
    [[0, 0, 0]]
  ],
  "2": [
    [[90, 90, 90], [270, 180, 270]],
    [[90, 180, 180], [0, 270, 0]],
    [[0, 90, 90], [270, 270, 270]]
  ],
  "3": [
    [[90, 90, 90], [270, 180, 270]],
    [[90, 90, 90], [0, 180, 270]],
    [[90, 90, 90], [0, 270, 0]]
  ],
  "4": [
    [[180, 180, 180], [180, 180, 180]],
    [[0, 90, 90], [0, 180, 270]],
    [[225, 225, 225], [0, 0, 0]]
  ],
  "5": [
    [[90, 180, 180], [270, 270, 270]],
    [[0, 90, 90], [270, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "6": [
    [[180, 90, 90], [270, 180, 270]],
    [[0, 90, 180], [270, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "7": [
    [[90, 180, 180], [180, 270, 270]],
    [[225, 225, 225], [0, 180, 180]],
    [[225, 225, 225], [0, 0, 0]]
  ],
  "8": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 90, 180], [0, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "9": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 90, 90], [0, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ]
};

// --- Animation and drawing logic ---
let timeDigits = ["1", "2", ":", "3", "0"];

function randomTimeDigits() {
  // Generate random hour (1-12) and minute (00-59) for 12-hour clock
  const hour = Math.floor(Math.random() * 12) + 1;
  const minute = Math.floor(Math.random() * 60);
  // Remove leading zero for single-digit hour
  const hourStr = String(hour);
  const minStr = String(minute).padStart(2, '0');
  let digits = [];
  if (hourStr.length === 1) {
    digits.push(hourStr);
  } else {
    digits.push(hourStr[0], hourStr[1]);
  }
  digits.push(':', minStr[0], minStr[1]);
  return digits;
}

function drawMatrix() {
  // Calculate total columns needed for the current timeDigits
  let digitColWidths = timeDigits.map(d => (d === '1' || d === ':') ? 1 : 2);
  let renderedCols = digitColWidths.reduce((a, b) => a + b, 0);
  let totalCols = Math.max(renderedCols, 8);
  let emptyCols = totalCols - renderedCols;

  // Calculate left pad for centering or right-justifying
  let leftPad = 0;
  if (emptyCols === 1) {
    leftPad = 1; // right justify
  } else if (emptyCols > 1) {
    leftPad = Math.ceil(emptyCols / 2); // center, extra on left
  }

  // Recompute width and update SVG size
  const dynamicWidth = spacing * (totalCols - 1) + cylinderOD + margin * 2 + outlineGap * 2;
  const dynamicHeight = spacing * (rows - 1) + cylinderOD + margin * 2 + outlineGap * 2;
  svg.setAttribute("viewBox", `0 0 ${dynamicWidth} ${dynamicHeight}`);

  let svgContent = "";
  // Bounding outline
  svgContent += `
    <rect
      x="${margin - outlineGap}"
      y="${margin - outlineGap}"
      width="${dynamicWidth - (margin - outlineGap) * 2}"
      height="${dynamicHeight - (margin - outlineGap) * 2}"
      class="outline"
    />
  `;

  // Render left pad as empty columns (draw as ' ' chars)
  let colCursor = 0;
  for (; colCursor < leftPad; colCursor++) {
    const grid = DIGITS[" "];
    for (let r = 0; r < rows; r++) {
      const cx = margin + outerRadius + colCursor * spacing + outlineGap;
      const cy = margin + outerRadius + r * spacing + outlineGap;
      svgContent += circle(cx, cy, outerRadius, "pixel");
      svgContent += circle(cx, cy, innerRadius, "safe");
      // Draw hands for space char
      if (grid && grid[r] && grid[r][0]) {
        grid[r][0].forEach((angle, idx) => {
          if (grid[r][0].length === 3 && idx === 2) {
            svgContent += hand(cx, cy, angle, innerRadius * 0.92, "hand hand-thin");
          } else {
            svgContent += hand(cx, cy, angle, innerRadius * 0.92, "hand");
          }
        });
      }
    }
  }
  // Render each digit, advancing by 2 columns for most, 1 for '1' or ':'
  for (let digitIndex = 0; digitIndex < timeDigits.length; digitIndex++) {
    const digit = timeDigits[digitIndex];
    const grid = DIGITS[digit];
    const digitCols = (digit === '1' || digit === ':') ? 1 : 2;
    for (let dc = 0; dc < digitCols; dc++) {
      for (let r = 0; r < rows; r++) {
        const cx = margin + outerRadius + (colCursor + dc) * spacing + outlineGap;
        const cy = margin + outerRadius + r * spacing + outlineGap;
        // outer circle
        svgContent += circle(cx, cy, outerRadius, "pixel");
        // inner visible area
        svgContent += circle(cx, cy, innerRadius, "safe");
        // Draw hands: always expect 3 angles per cell
        if (grid && grid[r] && grid[r][dc]) {
          const angles = grid[r][dc];
          for (let idx = 0; idx < 3; idx++) {
            const angle = angles[idx];
            if (idx === 2) {
              svgContent += hand(cx, cy, angle, innerRadius * 0.92, "hand hand-thin");
            } else {
              svgContent += hand(cx, cy, angle, innerRadius * 0.92, "hand");
            }
          }
        } else {
          // If no grid or no cell, treat as empty pixel (should not occur with current DIGITS)
          for (let idx = 0; idx < 3; idx++) {
            svgContent += hand(cx, cy, 225, innerRadius * 0.92, idx === 2 ? "hand hand-thin" : "hand");
          }
        }
      }
    }
    colCursor += digitCols;
  }
  // Pad with empty columns if needed (right side, draw as ' ' chars)
  for (; colCursor < totalCols; colCursor++) {
    const grid = DIGITS[" "];
    for (let r = 0; r < rows; r++) {
      const cx = margin + outerRadius + colCursor * spacing + outlineGap;
      const cy = margin + outerRadius + r * spacing + outlineGap;
      svgContent += circle(cx, cy, outerRadius, "pixel");
      svgContent += circle(cx, cy, innerRadius, "safe");
      // Draw hands for space char
      if (grid && grid[r] && grid[r][0]) {
        grid[r][0].forEach((angle, idx) => {
          if (grid[r][0].length === 3 && idx === 2) {
            svgContent += hand(cx, cy, angle, innerRadius * 0.92, "hand hand-thin");
          } else {
            svgContent += hand(cx, cy, angle, innerRadius * 0.92, "hand");
          }
        });
      }
    }
  }
  svg.innerHTML = svgContent;
}

// Initial draw
drawMatrix();


// Animate every 5 seconds, and allow space bar to advance
let timer = setInterval(nextTime, 5000);

function nextTime() {
  timeDigits = randomTimeDigits();
  drawMatrix();
}

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    clearInterval(timer);
    nextTime();
    timer = setInterval(nextTime, 5000);
  }
});



/* ---- Draw pixels ---- */
</script>

</body>
</html>
