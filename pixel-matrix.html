<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
      <select id="rippleSpeedSelect" style="margin-left:16px; display:none;">
        <option value="0.2">Very Fast</option>
        <option value="0.4">Fast</option>
        <option value="0.6">Normal</option>
        <option value="0.8">Slow</option>
        <option value="1.0">Very Slow</option>
      </select>
      <span id="rippleSpeedLabel" style="display:none;">Ripple speed</span>
    <select id="rippleSelect" style="margin-left:16px; display:none;">
      <option value="none">No Ripple</option>
      <option value="left-right">Left to Right</option>
      <option value="right-left">Right to Left</option>
      <option value="top-bottom">Top to Bottom</option>
      <option value="bottom-top">Bottom to Top</option>
      <option value="center-out">Center Out</option>
      <option value="edges-in">Edges In</option>
    </select>
    <span id="rippleLabel" style="display:none;">Ripple direction</span>
  <meta charset="UTF-8" />
  <title>Virtual Pixel Matrix – Scale Layout</title>
  <style>
    body {
      background: #f5f5f5;
      font-family: sans-serif;
    }
    svg {
      background: white;
      border: 1px solid #ccc;
      width: 100vw;
      height: auto;
      display: block;
      max-width: 100%;
    }
    .pixel {
      stroke: #4da3ff;
      stroke-width: 1.5;
      fill: none;
    }
    .safe {
      stroke: #cce6ff;
      stroke-width: 1;
      stroke-dasharray: 4 4;
      fill: none;
    }
    .hand {
      stroke: #111;
      stroke-width: 3;
      stroke-linecap: round;
    }
    .hand-thin {
      stroke-width: 2.4; /* 80% of 3 */
      stroke: #111;
    }
    .hand-placeholder {
      stroke: #ccc;
      stroke-width: 2;
    }
    .outline {
      stroke: #000;
      stroke-width: 2;
      fill: none;
    }
  </style>
</head>
<body>
<label style="display:block;margin:10px 0;">
</label>
  <select id="easingSelect" style="margin-right:8px;">
    <option value="elastic">Elastic</option>
    <option value="linear">Linear</option>
    <option value="ease-in-out">Ease-in-out</option>
    <option value="bounce">Bounce</option>
    <option value="back-in">Back (at start)</option>
    <option value="back-out">Back (at end)</option>
    <option value="back-in-out">Back (in & out)</option>
    <option value="random">Random</option>
  </select>
  Animation easing
  <select id="durationSelect" style="margin-left:16px;">
    <option value="600">0.6 seconds (Fastest)</option>
    <option value="1000">1 second (Faster)</option>
    <option value="1600">1.6 seconds (Fast)</option>
    <option value="2400">2.4 seconds (Normal)</option>
    <option value="3500">3.5 seconds (Slow)</option>
    <option value="5000">5 seconds (Slower)</option>
    <option value="8000">8 seconds (Slowest)</option>
  </select>
  Animation duration
</label>
</label>
<div style="background:#eef;padding:10px 16px;margin-bottom:10px;border-radius:8px;max-width:600px;">
  <b>Instructions:</b><br>
  <ul style="margin:8px 0 0 18px;padding:0;">
    <li><b>Left/Right Arrow</b>: Step time backward/forward by 1 minute</li>
    <li><b>Spacebar</b>: Randomize the time</li>
    <li><b>Enable 5 second timer</b>: When checked, time advances automatically every 5 seconds</li>
  </ul>
</div>


<label style="display:block;margin:10px 0;">
  <input type="checkbox" id="timerCheckbox" checked> Enable 5 second timer
</label>
<svg id="svg"></svg>

<script>
/* ---- Physical parameters (mm) ---- */
const cols = 8;
const rows = 3;
const cylinderOD = 44.0; // outer diameter
const visibleDiameter = 34.6; // inner visible diameter
const cylinderGap = 2.75; // gap between outside circles

/* ---- Derived geometry ---- */
const outerRadius = cylinderOD / 2;
const innerRadius = visibleDiameter / 2;
const spacing = 46.75; // center-to-center distance in mm

/* ---- SVG sizing ---- */

const outlineGap = cylinderGap * 3; // triple gap for outline
const margin = cylinderGap; // gap between outline and edge circles
const width = spacing * (cols - 1) + cylinderOD + margin * 2 + outlineGap * 2;
const height = spacing * (rows - 1) + cylinderOD + margin * 2 + outlineGap * 2;

const svg = document.getElementById("svg");
svg.style.width = "100vw";
svg.style.height = "auto";
svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

/* ---- Helpers ---- */
function circle(cx, cy, r, cls) {
  return `<circle cx="${cx}" cy="${cy}" r="${r}" class="${cls}" />`;
}

function hand(cx, cy, angleDeg, length, cls="hand") {
  const rad = (angleDeg - 90) * Math.PI / 180;
  const x2 = cx + Math.cos(rad) * length;
  const y2 = cy + Math.sin(rad) * length;
  return `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" class="${cls}" />`;
}


// ---- Digit hand definitions ----
// Each digit is defined as a grid of rows and columns:
// - Most digits use a 3x2 grid: [ [row0col0, row0col1], [row1col0, row1col1], [row2col0, row2col1] ]
// - ':' and '1' use a 3x1 grid: [ [row0], [row1], [row2] ]
// Each cell is an array: [angle1, angle2, angle3, style?]
//   - angle1, angle2, angle3: degrees for the 3 hands in that pixel (always present)
//   - style (optional): 1 = normal hands, 2 = short/light gray hands
// Angles: 0=up, 90=right, 180=down, 225=empty, 270=left
const DIGITS = {
  // ':' is a single column, dots in top and bottom row
  ":": [
    [[180, 180, 180]],
    [[225, 225, 225, 2]],
    [[0, 0, 0]]
  ],
  // ' ' (space) is a single column, all 225° hands, style 2
  " ": [
    [[225, 225, 225, 2]],
    [[225, 225, 225, 2]],
    [[225, 225, 225, 2]]
  ],
  "0": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 180, 180], [0, 180, 180]],
    [[0, 90, 90], [0, 270, 270]]
  ],
  "1": [
    [[180, 180, 180]],
    [[0, 180, 180]],
    [[0, 0, 0]]
  ],
  "2": [
    [[90, 90, 90], [270, 180, 270]],
    [[90, 180, 180], [0, 270, 0]],
    [[0, 90, 90], [270, 270, 270]]
  ],
  "3": [
    [[90, 90, 90], [270, 180, 270]],
    [[90, 90, 90], [0, 180, 270]],
    [[90, 90, 90], [0, 270, 0]]
  ],
  "4": [
    [[180, 180, 180], [180, 180, 180]],
    [[0, 90, 90], [0, 180, 270]],
    [[225, 225, 225, 2], [0, 0, 0]]
  ],
  "5": [
    [[90, 180, 180], [270, 270, 270]],
    [[0, 90, 90], [270, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "6": [
    [[180, 90, 90], [270, 180, 270]],
    [[0, 90, 180], [270, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "7": [
    [[90, 180, 180], [180, 270, 270]],
    [[225, 225, 225, 2], [0, 180, 180]],
    [[225, 225, 225, 2], [0, 0, 0]]
  ],
  "8": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 90, 180], [0, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "9": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 90, 90], [0, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ]
};

// --- Animation and drawing logic ---
// Globals for random mode
let randomEasing = 'elastic';
let randomTiming = 1.0;

let timeDigits = ["1", "2", ":", "3", "0"];
let prevGrid = null;
let animationFrameId = null;
let currentHour = 12;
let currentMinute = 0;


function randomTimeDigits() {
  // Generate random hour (1-12) and minute (00-59) for 12-hour clock
  const hour = Math.floor(Math.random() * 12) + 1;
  const minute = Math.floor(Math.random() * 60);
  return formatTimeDigits(hour, minute);
}



function sequentialTimeDigits(delta = 1) {
  // Change time by delta minutes (default +1)
  let totalMinutes = (currentHour - 1) * 60 + currentMinute + delta;
  if (totalMinutes < 0) totalMinutes += 12 * 60;
  totalMinutes = totalMinutes % (12 * 60);
  currentHour = Math.floor(totalMinutes / 60) + 1;
  currentMinute = totalMinutes % 60;
  return formatTimeDigits(currentHour, currentMinute);
}

function formatTimeDigits(hour, minute) {
  // Remove leading zero for single-digit hour
  const hourStr = String(hour);
  const minStr = String(minute).padStart(2, '0');
  let digits = [];
  if (hourStr.length === 1) {
    digits.push(hourStr);
  } else {
    digits.push(hourStr[0], hourStr[1]);
  }
  digits.push(':', minStr[0], minStr[1]);
  return digits;
}

function drawMatrix() {
  // --- Animation-aware rendering ---
  // Build prevGrid and nextGrid for animation
  let digitColWidths = timeDigits.map(d => (d === '1' || d === ':') ? 1 : 2);
  let renderedCols = digitColWidths.reduce((a, b) => a + b, 0);
  let totalCols = Math.max(renderedCols, 8);
  let emptyCols = totalCols - renderedCols;
  let leftPad = 0;
  if (emptyCols === 1) {
    leftPad = 1;
  } else if (emptyCols > 1) {
    leftPad = Math.ceil(emptyCols / 2);
  }
  // Calculate dynamicWidth and dynamicHeight for animation
  const dynamicWidth = spacing * (totalCols - 1) + cylinderOD + margin * 2 + outlineGap * 2;
  const dynamicHeight = spacing * (rows - 1) + cylinderOD + margin * 2 + outlineGap * 2;
  svg.setAttribute("viewBox", `0 0 ${dynamicWidth} ${dynamicHeight}`);

  // Build nextGrid: [col][row] = [angle1, angle2, angle3, style]
  let nextGrid = [];
  let colCursor = 0;
  // Left pad
  for (; colCursor < leftPad; colCursor++) {
    for (let r = 0; r < rows; r++) {
      nextGrid.push([colCursor, r, DIGITS[" "][r][0]]);
    }
  }
  // Digits
  for (let digitIndex = 0; digitIndex < timeDigits.length; digitIndex++) {
    const digit = timeDigits[digitIndex];
    const grid = DIGITS[digit];
    const digitCols = (digit === '1' || digit === ':') ? 1 : 2;
    for (let dc = 0; dc < digitCols; dc++) {
      for (let r = 0; r < rows; r++) {
        nextGrid.push([colCursor + dc, r, grid[r][dc]]);
      }
    }
    colCursor += digitCols;
  }
  // Right pad
  for (; colCursor < totalCols; colCursor++) {
    for (let r = 0; r < rows; r++) {
      nextGrid.push([colCursor, r, DIGITS[" "][r][0]]);
    }
  }
  // Animate hands from prevGrid to nextGrid
  // Get user-selected duration
  const durationSelect = document.getElementById('durationSelect');
  const savedDuration = localStorage.getItem('pixelMatrixDuration');
  let totalDuration = 1600;
  if (savedDuration) {
    totalDuration = parseInt(savedDuration, 10);
  } else if (durationSelect && durationSelect.value) {
    totalDuration = parseInt(durationSelect.value, 10);
  }
  const start = performance.now();
  // Ripple logic
  const rippleSelect = document.getElementById('rippleSelect');
  const savedRipple = localStorage.getItem('pixelMatrixRippleMode');
  let rippleMode = 'none';
  if (savedRipple) {
    rippleMode = savedRipple;
    rippleSelect.value = savedRipple;
  } else if (rippleSelect && rippleSelect.value) {
    rippleMode = rippleSelect.value;
  }
  // Compute per-pixel ripple delay
  let delays = [];
  // Ripple speed
  const rippleSpeedSelect = document.getElementById('rippleSpeedSelect');
  const savedRippleSpeed = localStorage.getItem('pixelMatrixRippleSpeed');
  let rippleSpeed = 0.6;
  if (savedRippleSpeed) {
    rippleSpeed = parseFloat(savedRippleSpeed);
    rippleSpeedSelect.value = savedRippleSpeed;
  } else if (rippleSpeedSelect && rippleSpeedSelect.value) {
    rippleSpeed = parseFloat(rippleSpeedSelect.value);
  }
  if (rippleMode !== 'none') {
    // Get grid positions for each pixel
    let positions = nextGrid.map(([col, row]) => ({col, row}));
    let maxDelay = totalDuration * rippleSpeed; // user controls spread
    let getDelay = (i) => 0;
    if (rippleMode === 'left-right') {
      let maxCol = Math.max(...positions.map(p => p.col));
      getDelay = (i) => (positions[i].col / maxCol) * maxDelay;
    } else if (rippleMode === 'right-left') {
      let maxCol = Math.max(...positions.map(p => p.col));
      getDelay = (i) => ((maxCol - positions[i].col) / maxCol) * maxDelay;
    } else if (rippleMode === 'top-bottom') {
      let maxRow = Math.max(...positions.map(p => p.row));
      getDelay = (i) => (positions[i].row / maxRow) * maxDelay;
    } else if (rippleMode === 'bottom-top') {
      let maxRow = Math.max(...positions.map(p => p.row));
      getDelay = (i) => ((maxRow - positions[i].row) / maxRow) * maxDelay;
    } else if (rippleMode === 'center-out') {
      let maxCol = Math.max(...positions.map(p => p.col));
      let maxRow = Math.max(...positions.map(p => p.row));
      let centerCol = maxCol / 2, centerRow = maxRow / 2;
      let maxDist = Math.sqrt(centerCol*centerCol + centerRow*centerRow);
      getDelay = (i) => {
        let dx = positions[i].col - centerCol;
        let dy = positions[i].row - centerRow;
        return (Math.sqrt(dx*dx + dy*dy) / maxDist) * maxDelay;
      };
    } else if (rippleMode === 'edges-in') {
      let maxCol = Math.max(...positions.map(p => p.col));
      let maxRow = Math.max(...positions.map(p => p.row));
      let centerCol = maxCol / 2, centerRow = maxRow / 2;
      let maxDist = Math.sqrt(centerCol*centerCol + centerRow*centerRow);
      getDelay = (i) => {
        let dx = positions[i].col - centerCol;
        let dy = positions[i].row - centerRow;
        return (1 - Math.sqrt(dx*dx + dy*dy) / maxDist) * maxDelay;
      };
    }
    for (let i = 0; i < nextGrid.length; i++) {
      delays[i] = getDelay(i);
    }
  } else {
    for (let i = 0; i < nextGrid.length; i++) delays[i] = 0;
  }
  // For each hand, randomize a duration (0.7-1.0x totalDuration), but apply ripple delay to the start time, not the duration
  let handDurations = [];
  let handDelays = [];
  // Pick one random easing for the entire animation phase
  const easingModes = ['elastic', 'linear', 'ease-in-out', 'bounce', 'back-in', 'back-out', 'back-in-out'];
  const randomEasing = easingModes[Math.floor(Math.random() * easingModes.length)];
  const randomTiming = 0.7 + Math.random() * 0.6;

  for (let i = 0; i < nextGrid.length; i++) {
    handDurations[i] = [
      totalDuration * (0.7 + Math.random() * 0.3),
      totalDuration * (0.7 + Math.random() * 0.3),
      totalDuration * (0.7 + Math.random() * 0.3)
    ];
    handDelays[i] = [delays[i], delays[i], delays[i]];
  }
  // Store random direction for each hand transition
  let angleDirections = [];
  let sweep360Arr = [];
  if (!prevGrid) prevGrid = nextGrid.map(cell => [...cell]);
  for (let i = 0; i < nextGrid.length; i++) {
    angleDirections[i] = [
      Math.random() < 0.5 ? 1 : -1,
      Math.random() < 0.5 ? 1 : -1,
      Math.random() < 0.5 ? 1 : -1
    ];
    // If the digit/cell is unchanged, set a flag for 360 sweep
    const prevCell = prevGrid && prevGrid[i] ? prevGrid[i][2] : null;
    const nextCell = nextGrid[i][2];
    sweep360Arr[i] = (prevCell && nextCell && prevCell.join() === nextCell.join());
  }
  function lerp(a, b, t) { return a + (b - a) * t; }
  function lerpAngle(a, b, t) {
    // This function will be overridden in renderFrame to use random direction
    let diff = ((b - a + 540) % 360) - 180;
    return (a + diff * t + 360) % 360;
  }
  function lerpColor(c1, c2, t) {
    // c1, c2: [r,g,b]
    return `rgb(${Math.round(lerp(c1[0],c2[0],t))},${Math.round(lerp(c1[1],c2[1],t))},${Math.round(lerp(c1[2],c2[2],t))})`;
  }

  // Easing functions
  function elasticEaseOut(t) {
    if (t === 0 || t === 1) return t;
    const c4 = (2 * Math.PI) / 3;
    return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
  }
  function linearEase(t) {
    return t;
  }
  function easeIn(t) {
    return t * t;
  }
  function easeOut(t) {
    return t * (2 - t);
  }
  function easeInOut(t) {
    // Smoothstep (S-curve)
    return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
  }
  function bounceEaseOut(t) {
    // Robert Penner's bounce ease out
    if (t < (1 / 2.75)) {
      return 7.5625 * t * t;
    } else if (t < (2 / 2.75)) {
      t -= (1.5 / 2.75);
      return 7.5625 * t * t + 0.75;
    } else if (t < (2.5 / 2.75)) {
      t -= (2.25 / 2.75);
      return 7.5625 * t * t + 0.9375;
    } else {
      t -= (2.625 / 2.75);
      return 7.5625 * t * t + 0.984375;
    }
  }
  function backEaseIn(t) {
    // Robert Penner's back ease in
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return c3 * t * t * t - c1 * t * t;
  }
  function backEaseOut(t) {
    // Robert Penner's back ease out
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }
  function backEaseInOut(t) {
    // Robert Penner's back ease in-out
    const c1 = 1.70158 * 1.525;
    return t < 0.5
      ? (Math.pow(2 * t, 2) * ((c1 + 1) * 2 * t - c1)) / 2
      : (Math.pow(2 * t - 2, 2) * ((c1 + 1) * (t * 2 - 2) + c1) + 2) / 2;
  }
  // Color definitions
  const color1 = [17,17,17]; // #111
  const color2 = [204,204,204]; // #ccc
  // Render function
  function renderFrame(now) {
            // Show/hide ripple speed dropdown based on ripple mode
            const rippleSpeedSelect = document.getElementById('rippleSpeedSelect');
            const rippleSpeedLabel = document.getElementById('rippleSpeedLabel');
            if (window.rippleSelect && window.rippleSelect.value !== 'none') {
              rippleSpeedSelect.style.display = 'inline-block';
              rippleSpeedLabel.style.display = 'inline-block';
            } else {
              rippleSpeedSelect.style.display = 'none';
              rippleSpeedLabel.style.display = 'none';
            }
            // Save ripple speed
            rippleSpeedSelect.addEventListener('change', () => {
              localStorage.setItem('pixelMatrixRippleSpeed', rippleSpeedSelect.value);
              if (animationFrameId) {
                if (typeof drawMatrix === 'function') drawMatrix();
              }
            });
        // Show/hide ripple dropdown based on mode
        const rippleSelect = document.getElementById('rippleSelect');
        const rippleLabel = document.getElementById('rippleLabel');
        rippleSelect.style.display = 'inline-block';
        rippleLabel.style.display = 'inline-block';
        // Save ripple mode
        rippleSelect.addEventListener('change', () => {
          localStorage.setItem('pixelMatrixRippleMode', rippleSelect.value);
          if (animationFrameId) {
            if (typeof drawMatrix === 'function') drawMatrix();
          }
        });
    // Duration select logic
    const durationSelect = document.getElementById('durationSelect');
    const savedDuration = localStorage.getItem('pixelMatrixDuration');
    if (savedDuration) {
      durationSelect.value = savedDuration;
    }
    window.durationSelect = durationSelect;
    durationSelect.addEventListener('change', () => {
      localStorage.setItem('pixelMatrixDuration', durationSelect.value);
      if (animationFrameId) {
        if (typeof drawMatrix === 'function') drawMatrix();
      }
    });

    // We'll use the max duration for the overall animation, but each hand will finish at its own time
    // Find the maximum (delay + duration) for any hand, so animation doesn't end early
    let maxHandEnd = 0;
    const mode = (window.easingSelect && window.easingSelect.value) || 'elastic';
    for (let i = 0; i < handDurations.length; i++) {
      for (let j = 0; j < 3; j++) {
        let duration = handDurations[i][j];
        // Account for randomTiming multiplier in random mode
        if (mode === 'random') {
          duration *= randomTiming;
        }
        let end = (handDelays && handDelays[i] ? handDelays[i][j] : 0) + duration;
        if (end > maxHandEnd) maxHandEnd = end;
      }
    }
    let t = Math.min((now - start) / maxHandEnd, 1);
    // Easing mode select logic
    const easingSelect = document.getElementById('easingSelect');
    const savedEasingMode = localStorage.getItem('pixelMatrixEasingMode');
    if (savedEasingMode) {
      easingSelect.value = savedEasingMode;
    }
    window.easingSelect = easingSelect;
    easingSelect.addEventListener('change', () => {
      localStorage.setItem('pixelMatrixEasingMode', easingSelect.value);
      if (animationFrameId) {
        if (typeof drawMatrix === 'function') drawMatrix();
      }
    });
    let svgContent = "";
    svgContent += `
      <rect
        x="${margin - outlineGap}"
        y="${margin - outlineGap}"
        width="${dynamicWidth - (margin - outlineGap) * 2}"
        height="${dynamicHeight - (margin - outlineGap) * 2}"
        class="outline"
      />
    `;
    for (let i = 0; i < nextGrid.length; i++) {
      const [col, row, nextCell] = nextGrid[i];
      let prevCell = prevGrid && prevGrid[i] ? prevGrid[i][2] : nextCell;
      const cx = margin + outerRadius + col * spacing + outlineGap;
      const cy = margin + outerRadius + row * spacing + outlineGap;
      svgContent += circle(cx, cy, outerRadius, "pixel");
      svgContent += circle(cx, cy, innerRadius, "safe");
      // Animate each hand
      for (let idx = 0; idx < 3; idx++) {
        const prevAngle = prevCell[idx];
        const nextAngle = nextCell[idx];
        const prevStyle = prevCell[3] || 1;
        const nextStyle = nextCell[3] || 1;
        // Per-hand progress and easing, with ripple delay
        let delay = handDelays[i][idx] || 0;
        let duration = handDurations[i][idx];
        let elapsed = now - start - delay;
        let handT = Math.max(0, Math.min(elapsed / duration, 1));
        let styleT;
        let mode = (window.easingSelect && window.easingSelect.value) || 'elastic';
        if (mode === 'random') {
          // Use the same random easing for all hands in this animation phase
          handT = Math.max(0, Math.min(elapsed / (duration * randomTiming), 1));
          if (randomEasing === 'elastic') styleT = elasticEaseOut(handT);
          else if (randomEasing === 'linear') styleT = linearEase(handT);
          else if (randomEasing === 'ease-in-out') styleT = easeInOut(handT);
          else if (randomEasing === 'bounce') styleT = bounceEaseOut(handT);
          else if (randomEasing === 'back-in') styleT = backEaseIn(handT);
          else if (randomEasing === 'back-out') styleT = backEaseOut(handT);
          else if (randomEasing === 'back-in-out') styleT = backEaseInOut(handT);
          else styleT = handT;
        } else {
          if (mode === 'elastic') styleT = elasticEaseOut(handT);
          else if (mode === 'linear') styleT = linearEase(handT);
          else if (mode === 'ease-in-out') styleT = easeInOut(handT);
          else if (mode === 'bounce') styleT = bounceEaseOut(handT);
          else if (mode === 'back-in') styleT = backEaseIn(handT);
          else if (mode === 'back-out') styleT = backEaseOut(handT);
          else if (mode === 'back-in-out') styleT = backEaseInOut(handT);
          else styleT = handT;
        }
        let direction = angleDirections[i][idx];
        let angle;
        if (sweep360Arr[i]) {
          // Always sweep a full circle in the random direction
          angle = (prevAngle + 360 * direction * styleT + 360) % 360;
        } else {
          // Normal shortest-path tween
          let diff = ((nextAngle - prevAngle + 540) % 360) - 180;
          if (direction === 1) {
            angle = (prevAngle + diff * styleT + 360) % 360;
          } else {
            angle = (prevAngle - (360 - Math.abs(diff)) * styleT * Math.sign(diff) + 360) % 360;
          }
        }
        // Style interpolation
        const style = styleT < 1 ? prevStyle : nextStyle;
        // Length tween
        const prevLength = prevStyle === 2 ? innerRadius * 0.65 : innerRadius * 0.92;
        const nextLength = nextStyle === 2 ? innerRadius * 0.65 : innerRadius * 0.92;
        const length = lerp(prevLength, nextLength, styleT);
        // Color tween
        const prevColorArr = prevStyle === 2 ? color2 : color1;
        const nextColorArr = nextStyle === 2 ? color2 : color1;
        const color = lerpColor(prevColorArr, nextColorArr, styleT);
        let cls = "hand";
        if (styleT < 1) {
          cls = prevStyle === 2 ? "hand-placeholder" : (idx === 2 ? "hand hand-thin" : "hand");
        } else {
          cls = nextStyle === 2 ? "hand-placeholder" : (idx === 2 ? "hand hand-thin" : "hand");
        }
        // Line thickness tween
        const prevThickness = prevStyle === 2 ? 2 : (idx === 2 ? 2.4 : 3);
        const nextThickness = nextStyle === 2 ? 2 : (idx === 2 ? 2.4 : 3);
        const thickness = lerp(prevThickness, nextThickness, styleT);
        // Tween or unify line ending style
        const linecap = 'round';
        svgContent += `<line x1="${cx}" y1="${cy}" x2="${cx + Math.cos((angle-90)*Math.PI/180)*length}" y2="${cy + Math.sin((angle-90)*Math.PI/180)*length}" style="stroke:${color};stroke-width:${thickness};stroke-linecap:${linecap}" class="${cls}" />`;
      }
    }
    svg.innerHTML = svgContent;
    if (t < 1) {
      animationFrameId = requestAnimationFrame(renderFrame);
    } else {
      animationFrameId = null;
      prevGrid = nextGrid;
      // Start timer only after animation completes
      if (timerCheckbox && timerCheckbox.checked) {
        // Prevent multiple timers
        if (!timer) startTimer();
      }
    }
  }
  if (animationFrameId) cancelAnimationFrame(animationFrameId);
  animationFrameId = requestAnimationFrame(renderFrame);
}

// Restore duration select state from localStorage
const durationSelect = document.getElementById('durationSelect');
const savedDuration = localStorage.getItem('pixelMatrixDuration');
if (savedDuration) {
  durationSelect.value = savedDuration;
}
durationSelect.addEventListener('change', () => {
  localStorage.setItem('pixelMatrixDuration', durationSelect.value);
});

// Initial draw
drawMatrix();


// Animate every 5 seconds, and allow space bar to advance





let timer = null;
const timerCheckbox = document.getElementById('timerCheckbox');
// Restore timer checkbox state from localStorage
const savedTimer = localStorage.getItem('pixelMatrixTimerEnabled');
if (savedTimer !== null) {
  timerCheckbox.checked = savedTimer === 'true';
}

function startTimer() {
  if (!timer) timer = setInterval(() => {
    // Only advance if no animation is running
    if (!animationFrameId) nextTime();
  }, 5000);
}
function stopTimer() {
  if (timer) { clearInterval(timer); timer = null; }
}

// Only start timer if checked and localStorage is true or not set
if (timerCheckbox.checked && (savedTimer === null || savedTimer === 'true') && !animationFrameId) startTimer();




function nextTime(delta = 1) {
  timeDigits = sequentialTimeDigits(delta);
  drawMatrix();
}

function randomizeTime() {
  // Set to a new random time
  const hour = currentHour = Math.floor(Math.random() * 12) + 1;
  const minute = currentMinute = Math.floor(Math.random() * 60);
  timeDigits = formatTimeDigits(hour, minute);
  drawMatrix();
}



document.addEventListener('keydown', (e) => {
  if (e.code === 'ArrowLeft') {
    stopTimer();
    nextTime(-1);
    if (timerCheckbox.checked) startTimer();
    e.preventDefault();
    return;
  } else if (e.code === 'ArrowRight') {
    stopTimer();
    nextTime(1);
    if (timerCheckbox.checked) startTimer();
    e.preventDefault();
    return;
  } else if (e.code === 'Space') {
    stopTimer();
    randomizeTime();
    if (timerCheckbox.checked) startTimer();
    e.preventDefault();
  }
});



// Checkbox for timer enable/disable
timerCheckbox.addEventListener('change', function(e) {
  localStorage.setItem('pixelMatrixTimerEnabled', timerCheckbox.checked);
  if (timerCheckbox.checked) {
    startTimer();
  } else {
    stopTimer();
  }
  // Remove focus to prevent spacebar toggling
  e.target.blur();
});



/* ---- Draw pixels ---- */
</script>

</body>
</html>
