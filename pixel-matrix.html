<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual Pixel Matrix – Scale Layout</title>
  <style>
    body {
      background: #f5f5f5;
      font-family: sans-serif;
    }
    svg {
      background: white;
      border: 1px solid #ccc;
      width: 100vw;
      height: auto;
      display: block;
      max-width: 100%;
    }
    .pixel {
      stroke: #4da3ff;
      stroke-width: 1.5;
      fill: none;
    }
    .safe {
      stroke: #cce6ff;
      stroke-width: 1;
      stroke-dasharray: 4 4;
      fill: none;
    }
    .hand {
      stroke: #111;
      stroke-width: 3;
      stroke-linecap: round;
    }
    .hand-thin {
      stroke-width: 2.4; /* 80% of 3 */
      stroke: #111;
    }
    .hand-placeholder {
      stroke: #ccc;
      stroke-width: 2;
    }
    .outline {
      stroke: #000;
      stroke-width: 2;
      fill: none;
    }
  </style>
</head>
<body>

<svg id="svg"></svg>

<script>
/* ---- Physical parameters (mm) ---- */
const cols = 8;
const rows = 3;
const cylinderOD = 44.0; // outer diameter
const visibleDiameter = 34.6; // inner visible diameter
const cylinderGap = 2.75; // gap between outside circles

/* ---- Derived geometry ---- */
const outerRadius = cylinderOD / 2;
const innerRadius = visibleDiameter / 2;
const spacing = 46.75; // center-to-center distance in mm

/* ---- SVG sizing ---- */

const outlineGap = cylinderGap * 3; // triple gap for outline
const margin = cylinderGap; // gap between outline and edge circles
const width = spacing * (cols - 1) + cylinderOD + margin * 2 + outlineGap * 2;
const height = spacing * (rows - 1) + cylinderOD + margin * 2 + outlineGap * 2;

const svg = document.getElementById("svg");
svg.style.width = "100vw";
svg.style.height = "auto";
svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

/* ---- Helpers ---- */
function circle(cx, cy, r, cls) {
  return `<circle cx="${cx}" cy="${cy}" r="${r}" class="${cls}" />`;
}

function hand(cx, cy, angleDeg, length, cls="hand") {
  const rad = (angleDeg - 90) * Math.PI / 180;
  const x2 = cx + Math.cos(rad) * length;
  const y2 = cy + Math.sin(rad) * length;
  return `<line x1="${cx}" y1="${cy}" x2="${x2}" y2="${y2}" class="${cls}" />`;
}


// ---- Digit hand definitions ----
// Each digit is defined as a grid of rows and columns:
// - Most digits use a 3x2 grid: [ [row0col0, row0col1], [row1col0, row1col1], [row2col0, row2col1] ]
// - ':' and '1' use a 3x1 grid: [ [row0], [row1], [row2] ]
// Each cell is an array: [angle1, angle2, angle3, style?]
//   - angle1, angle2, angle3: degrees for the 3 hands in that pixel (always present)
//   - style (optional): 1 = normal hands, 2 = short/light gray hands
// Angles: 0=up, 90=right, 180=down, 225=empty, 270=left
const DIGITS = {
  // ':' is a single column, dots in top and bottom row
  ":": [
    [[180, 180, 180]],
    [[225, 225, 225, 2]],
    [[0, 0, 0]]
  ],
  // ' ' (space) is a single column, all 225° hands, style 2
  " ": [
    [[225, 225, 225, 2]],
    [[225, 225, 225, 2]],
    [[225, 225, 225, 2]]
  ],
  "0": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 180, 180], [0, 180, 180]],
    [[0, 90, 90], [0, 270, 270]]
  ],
  "1": [
    [[180, 180, 180]],
    [[0, 180, 180]],
    [[0, 0, 0]]
  ],
  "2": [
    [[90, 90, 90], [270, 180, 270]],
    [[90, 180, 180], [0, 270, 0]],
    [[0, 90, 90], [270, 270, 270]]
  ],
  "3": [
    [[90, 90, 90], [270, 180, 270]],
    [[90, 90, 90], [0, 180, 270]],
    [[90, 90, 90], [0, 270, 0]]
  ],
  "4": [
    [[180, 180, 180], [180, 180, 180]],
    [[0, 90, 90], [0, 180, 270]],
    [[225, 225, 225, 2], [0, 0, 0]]
  ],
  "5": [
    [[90, 180, 180], [270, 270, 270]],
    [[0, 90, 90], [270, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "6": [
    [[180, 90, 90], [270, 180, 270]],
    [[0, 90, 180], [270, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "7": [
    [[90, 180, 180], [180, 270, 270]],
    [[225, 225, 225, 2], [0, 180, 180]],
    [[225, 225, 225, 2], [0, 0, 0]]
  ],
  "8": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 90, 180], [0, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ],
  "9": [
    [[90, 180, 180], [180, 270, 270]],
    [[0, 90, 90], [0, 180, 270]],
    [[0, 90, 90], [0, 270, 0]]
  ]
};

// --- Animation and drawing logic ---
let timeDigits = ["1", "2", ":", "3", "0"];
let prevGrid = null;
let animationFrameId = null;

function randomTimeDigits() {
  // Generate random hour (1-12) and minute (00-59) for 12-hour clock
  const hour = Math.floor(Math.random() * 12) + 1;
  const minute = Math.floor(Math.random() * 60);
  // Remove leading zero for single-digit hour
  const hourStr = String(hour);
  const minStr = String(minute).padStart(2, '0');
  let digits = [];
  if (hourStr.length === 1) {
    digits.push(hourStr);
  } else {
    digits.push(hourStr[0], hourStr[1]);
  }
  digits.push(':', minStr[0], minStr[1]);
  return digits;
}

function drawMatrix() {
  // --- Animation-aware rendering ---
  // Build prevGrid and nextGrid for animation
  let digitColWidths = timeDigits.map(d => (d === '1' || d === ':') ? 1 : 2);
  let renderedCols = digitColWidths.reduce((a, b) => a + b, 0);
  let totalCols = Math.max(renderedCols, 8);
  let emptyCols = totalCols - renderedCols;
  let leftPad = 0;
  if (emptyCols === 1) {
    leftPad = 1;
  } else if (emptyCols > 1) {
    leftPad = Math.ceil(emptyCols / 2);
  }
  // Calculate dynamicWidth and dynamicHeight for animation
  const dynamicWidth = spacing * (totalCols - 1) + cylinderOD + margin * 2 + outlineGap * 2;
  const dynamicHeight = spacing * (rows - 1) + cylinderOD + margin * 2 + outlineGap * 2;
  svg.setAttribute("viewBox", `0 0 ${dynamicWidth} ${dynamicHeight}`);

  // Build nextGrid: [col][row] = [angle1, angle2, angle3, style]
  let nextGrid = [];
  let colCursor = 0;
  // Left pad
  for (; colCursor < leftPad; colCursor++) {
    for (let r = 0; r < rows; r++) {
      nextGrid.push([colCursor, r, DIGITS[" "][r][0]]);
    }
  }
  // Digits
  for (let digitIndex = 0; digitIndex < timeDigits.length; digitIndex++) {
    const digit = timeDigits[digitIndex];
    const grid = DIGITS[digit];
    const digitCols = (digit === '1' || digit === ':') ? 1 : 2;
    for (let dc = 0; dc < digitCols; dc++) {
      for (let r = 0; r < rows; r++) {
        nextGrid.push([colCursor + dc, r, grid[r][dc]]);
      }
    }
    colCursor += digitCols;
  }
  // Right pad
  for (; colCursor < totalCols; colCursor++) {
    for (let r = 0; r < rows; r++) {
      nextGrid.push([colCursor, r, DIGITS[" "][r][0]]);
    }
  }
  // Animate hands from prevGrid to nextGrid
  const duration = 3000;
  const start = performance.now();
  // Store random direction for each hand transition
  let angleDirections = [];
  if (!prevGrid) prevGrid = nextGrid.map(cell => [...cell]);
  for (let i = 0; i < nextGrid.length; i++) {
    angleDirections[i] = [
      Math.random() < 0.5 ? 1 : -1,
      Math.random() < 0.5 ? 1 : -1,
      Math.random() < 0.5 ? 1 : -1
    ];
  }
  function lerp(a, b, t) { return a + (b - a) * t; }
  function lerpAngle(a, b, t) {
    // This function will be overridden in renderFrame to use random direction
    let diff = ((b - a + 540) % 360) - 180;
    return (a + diff * t + 360) % 360;
  }
  function lerpColor(c1, c2, t) {
    // c1, c2: [r,g,b]
    return `rgb(${Math.round(lerp(c1[0],c2[0],t))},${Math.round(lerp(c1[1],c2[1],t))},${Math.round(lerp(c1[2],c2[2],t))})`;
  }
  // Color definitions
  const color1 = [17,17,17]; // #111
  const color2 = [204,204,204]; // #ccc
  // Render function
  function renderFrame(now) {
    let t = Math.min((now - start) / duration, 1);
    let svgContent = "";
    svgContent += `
      <rect
        x="${margin - outlineGap}"
        y="${margin - outlineGap}"
        width="${dynamicWidth - (margin - outlineGap) * 2}"
        height="${dynamicHeight - (margin - outlineGap) * 2}"
        class="outline"
      />
    `;
    for (let i = 0; i < nextGrid.length; i++) {
      const [col, row, nextCell] = nextGrid[i];
      let prevCell = prevGrid && prevGrid[i] ? prevGrid[i][2] : nextCell;
      const cx = margin + outerRadius + col * spacing + outlineGap;
      const cy = margin + outerRadius + row * spacing + outlineGap;
      svgContent += circle(cx, cy, outerRadius, "pixel");
      svgContent += circle(cx, cy, innerRadius, "safe");
      // Animate each hand
      for (let idx = 0; idx < 3; idx++) {
        const prevAngle = prevCell[idx];
        const nextAngle = nextCell[idx];
        const prevStyle = prevCell[3] || 1;
        const nextStyle = nextCell[3] || 1;
        // Interpolate angle, length, and color
        const styleT = t;
        // Angle tween with random direction (sign only, always ends at target)
        let diff = ((nextAngle - prevAngle + 540) % 360) - 180;
        let direction = angleDirections[i][idx];
        // If direction is wrong, go the other way around the circle
        if (direction === 1) {
          // normal shortest path
          var angle = (prevAngle + diff * styleT + 360) % 360;
        } else {
          // go the long way around
          var angle = (prevAngle - (360 - Math.abs(diff)) * styleT * Math.sign(diff) + 360) % 360;
        }
        // Style interpolation
        const style = styleT < 1 ? prevStyle : nextStyle;
        // Length tween
        const prevLength = prevStyle === 2 ? innerRadius * 0.65 : innerRadius * 0.92;
        const nextLength = nextStyle === 2 ? innerRadius * 0.65 : innerRadius * 0.92;
        const length = lerp(prevLength, nextLength, styleT);
        // Color tween
        const prevColorArr = prevStyle === 2 ? color2 : color1;
        const nextColorArr = nextStyle === 2 ? color2 : color1;
        const color = lerpColor(prevColorArr, nextColorArr, styleT);
        let cls = "hand";
        if (styleT < 1) {
          cls = prevStyle === 2 ? "hand-placeholder" : (idx === 2 ? "hand hand-thin" : "hand");
        } else {
          cls = nextStyle === 2 ? "hand-placeholder" : (idx === 2 ? "hand hand-thin" : "hand");
        }
        // Line thickness tween
        const prevThickness = prevStyle === 2 ? 2 : (idx === 2 ? 2.4 : 3);
        const nextThickness = nextStyle === 2 ? 2 : (idx === 2 ? 2.4 : 3);
        const thickness = lerp(prevThickness, nextThickness, styleT);
        // Tween or unify line ending style
        const linecap = 'round';
        svgContent += `<line x1="${cx}" y1="${cy}" x2="${cx + Math.cos((angle-90)*Math.PI/180)*length}" y2="${cy + Math.sin((angle-90)*Math.PI/180)*length}" style="stroke:${color};stroke-width:${thickness};stroke-linecap:${linecap}" class="${cls}" />`;
      }
    }
    svg.innerHTML = svgContent;
    if (t < 1) animationFrameId = requestAnimationFrame(renderFrame);
    else {
      animationFrameId = null;
      prevGrid = nextGrid;
    }
  }
  if (animationFrameId) cancelAnimationFrame(animationFrameId);
  animationFrameId = requestAnimationFrame(renderFrame);
}

// Initial draw
drawMatrix();


// Animate every 5 seconds, and allow space bar to advance
let timer = setInterval(nextTime, 5000);

function nextTime() {
  timeDigits = randomTimeDigits();
  drawMatrix();
}

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    clearInterval(timer);
    nextTime();
    timer = setInterval(nextTime, 5000);
  }
});



/* ---- Draw pixels ---- */
</script>

</body>
</html>
